created: 20220224003122054
modified: 20220224005711689
tags: [[посты из чата]]
title: Две фундаментальные задачи
type: text/vnd.tiddlywiki

В этом проблема прямого мапинга. И в этом проблема цпп. И чтобы её решить от этого нужно уйти. Если ты хочешь ir - он должен быть полиморфным. А далее проблема не решается - всё равно остаётся проблема монорфизации.

И здесь есть две фундаментальные задачи. а) создать полиморфную модель. б) транслировать её в мономорфную форму, которая уже существует в реальности. Если мы говорим на уровне привычных абстракций. Пока ты не решил задачу а - нет смысла думать о задаче б. Поэтому абсолютно насрать как и что работает.

Интерпретатор для подобной логики ты написать сможешь. Об этом я так же говорил выше. Я так же рассуждал о том как компилировать нормальную модель - она не компилируется. Я не придумал как это сделать. Но в любом случае мне даже лень об этом думать на текущем этапе хватит и просто интерпретации. А далее уже думать, потому как все нюансы в голове не удержишь.

По поводу була. Смотри, есть базовая модель. В этой модели источником полиморфизма является T где-то в параметре функции. Если проще, то полиморфный контекст не может создаваться внутри мономорфного. Полиморфный контекст создаётся сверху. Очень наглядно это видно в районе раста на примере тех же лямбд. Вот твоё ``if(bool)`` - это сплит, т.е. разделение мономорного контекста на два. Этого не существует ни в одной модели. Всё что есть в текущих потугах - это костыль через сумтип. Но сумтип - это не полиморфно. Тип там так же теряется. Вот, чтобы работал твой иф - полиморфный контекст должен мочь создаваться в рамках этого if, либо в рамках любого выражения. Это примерно так, если бы ты мог создавать полиморфные переменные.

Не ``auto``, а именно полиморфные. Допустим, я приводил пример. ``auto x = variant.value;`` Это написать мы не можем. Потому как хоть там и auto - это мономорфный контекст. Мы можем сделать его полиморфным, сделав ту сущность в рамках которой он определён полиморфной(генерик/шаблонной), но это не то. В рамках нормального языка этот код должен работать.

Если далее мы напишем ``x.foo();`` то это на самом деле написание кода для одновременно всех типов. Если попроще - это шаблон. В результате в языке не будет каких-то там функций, либо отдельных элементов полиморфных, которые на самом деле шаблоны поверх момноморфных. Это так не будет работать.

Вот это нужно реализовать. Далее, повторяюсь, это так же потребует трансляции в мономорфное дерьмо. Но оно никак не зависит и не построено на базе этого мономорфного дерьма. И подобная модель вообще не ложится на компиляцию, особенно если с фичами. Поэтому я предлагаю вм/жит. Если компилировать это напрямую - компилироваться это будет в такой треш и настолько долго.

Проблема должна быть понятна из текста выше. Если мы делаем ``foo => if(bool)``, то на самом деле на нужно сплитать ''foo''. и так далее. А если там будет 2 аргумента с булами, то это уже 2*2 вариации. А если эта функция вложена куда-то - это + n вариаций.

Ах да, наверное так будет проще понять. Отвязывание ещё позволяет не компилировать одно и тоже. Допустим, если мы на цпп напишем две функции, которые делают одно и тоже, но с разными типами - на самом деле нам насрать на то, какую функции запускать. Это одно из свойств описанной мною модели. Когда мы выделяем рт/кт-сущности, то выделив всё рт из разного кода - может оказаться так(и в 90% так и окажется), что весь код в рт одинаковый. Без всего этого компиляция превращается в ад.

Если максимально просто. <a href="https://godbolt.org/z/8KT1rdzhe">https://godbolt.org/z/8KT1rdzhe</a> - суть в этом. Т.е. функции 4, но сами функции идентичные. На самом деле в цпп такого кода много. Много его выпиливается ещё на уровне cosntexpr. В том же дерьморасте подобного кода 99%. Поэтому если бы функция существовала отдельно, а её представление в рантайме отдельно, то все 4 вызова можно заменить на одну функцию. Чтобы это было, то существовать всё это должно выше ир. 

Это ещё одна проблема. Если ты что-то там делаешь на уровне ir, то ты не знаешь какая логика рождена из какой. Т.е. как ты узнаешь из того же ir для этих 4 функций, что это на самом деле одна функция? Любые потуги с каким-то представлением - это дерьмо по определению. Существует оно только для того, чтобы растошлюхи могли воровать. Вот как это реализовать на уровне того же языкового представления, а не промежуточного?

У тебя есть ''add''. У ''add'' есть ''compile_for'', далее в рамках этого ты можешь реализовать так, чтобы для a, b и b, a - оно возвращало ту же функцию. Это делается элементарно. Ну а теперь сделай это на уровне ir.